# /// script
# requires-python = ">=3.10"
# dependencies = [
#     "numpy==2.4.1",
#     "sympy==1.14.0",
# ]
# ///

import marimo

__generated_with = "0.18.3"
app = marimo.App(
    width="medium",
    app_title="Improved Simulation of Stabilizer Circuit",
    layout_file="layouts/main.slides.json",
)


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Improved Simulation of Stabilizer Circuits
    - Scott Aaronson
    - Daniel Gottesman
    - https://arxiv.org/abs/quant-ph/0406196

    $$
    \def\stab{\operatorname{stab}}
    \def\tr{\operatorname{tr}}
    \def\rank{\operatorname{rank}}
    \def\gen#1{\left\langle~#1~\right\rangle}
    \def\vv#1{\overrightarrow{#1}}
    \def\mat#1#2{\left\lgroup\begin{array}{#1}#2\end{array}\right\rgroup}
    $$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Contributions of the paper
    1. Removes gaussian elimination in measurement simulation.
       - Time complexity improvement: $O(n^3) \to O(n^2)$
       - At the cost of space complexity increase: 2x
    2. Shows that the problem of simulating stabilizer circuits is complete for the
    classical complexity class $\oplus\rm L$.
    3. Efficient algorithms for computing the inner product between two stabilizer states.
       - By putting any $n$-qubit stabilizer circuit into a “canonical form”
       - This form requires at most $O(n^2/\log n)$ gates, and other useful tasks
    4. Extend simulation capabilities.
       - Mixed states, without keeping track of pure states
       - Circuit with small number of non-stabilizer gates
       - Circuit with arbitrary tensor-product initial states, but small number of measurements
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Preliminaries
    ## Clifford/Stabilizer Circuit Gates
    - Hadamard gate $(H)$
    - Phase gate $(S)$
        - $S\ket0 = \ket0$
        - $S\ket1 = i\ket1$
    - Controlled not gate $(C_1X_2)$
    - Any gate that can be generated by the above ones. For example:
        - $Z = S\cdot S = S^2$
        - $X = HS^2H$
        - $C_1Z_2 = (I\otimes H)(C_1X_2)(I\otimes H)$
    - Alternatively, any unitary gate $(U)$ that conjugates Pauli $(P)$ to that/another Pauli $(Q)$
        - $UPU^\dag=Q$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Single-Qubit Pauli Operators
    - There are 4 single-qubit Pauli operators (including identity): $\{I,X,Y,Z\}$
    - Forms a basis for $2\times2$ matrices.
    - Any two such Pauli operators either commute or anticommute: $PQ = \pm QP$
        - Commutes iff $P=Q$ or either of them is $I$.
    - The only two eigenvalues are $\pm1$ (except for $I$ whose both eigenvalues are $+1$). Because,
        - $P^2=I\implies\lambda^2=1\implies\lambda\in\{+1,-1\}.$
        - $\tr(P) = 0 \implies \lambda_1+\lambda_2=0\implies\lambda=1,-1.$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## $n$-Qubit Pauli Strings $(\mathbb P_n)$
    These are tensor products of $n$ single-qubit Pauli operators
    - Example: $X\otimes I\otimes Z \otimes Y$
    - Alternative notation: $X_1Z_3Y_4$
    - There are $4^n$ such possible strings
    - Any two $n$-qubit Pauli strings also either commute or anticommute: $PQ = \pm QP$
        - Commutes iff even number of single-qubit Pauli operators anticommute $P$ and $Q$
    - Half of the eigenvalues are $+1$ and other half are $-1$ (except for $I_n$).
        - Only posstible eigenvalues are $\pm 1$ because $P^2=I \implies\lambda^2=1$
        - All $2^n$ eigenvalues for identity operator $I_n$ is $+1$.
        - Otherwise, the operators have $\dfrac{2^n}2$ eigenvalues that are $+1$ and $\dfrac{2^n}2$ eigenvalues that are  $-1$.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## $n$-Qubit Pauli Group $(\mathcal P_n)$
    These operators form a group over the matrix multiplication operation if $i^k$ phases are also included
    - There are $4^{n+1} = 4\times 4^n$ since $i$ can only have power $0,1,2$ or $3$.
    - Example: $-iX_1Z_3Y_4$
    - For all $P\in\mathcal P_n$:
        - If $P$ has a phase of $\pm1$, then $P^2=I_n$
        - Else $P$ has a phase of $\pm i$, and $P^2=-I_n$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Single-Qubit Pauli to Bits Mapping
    - If $P\in\{I,X,Y,Z\}$, and it represented with the 2 bits $(x,z)$, then
        - $I=X^0Z^0\leftrightarrow(0,0)\to00$
        - $Z=X^0Z^1\leftrightarrow(0,1)\to01$
        - $X=X^1Z^0\leftrightarrow(1,0)\to10$
        - $Y=iX^1Z^1\leftrightarrow(1,1)\to11$
        - $\boxed{P=i^{xz}X^xZ^z\leftrightarrow(x,z)}$
    - Pauli anticommutivity with exponent: $X^xZ^z = (-1)^{xz}Z^zX^x$
    - If $P$ and $P'$ are two single-qubit Paulis, we can calculate $PP'$:
        - Let $P=i^{xz}X^xZ^z\leftrightarrow(x,z)$ and $P' = i^{x'z'}X^{x'}Z^{z'}\leftrightarrow(x',z')$
        - Then $PP' = i^{xz+x'z'}X^xZ^zX^{x'}Z^{z'} = i^{xz+x'z'}(-1)^{x'z}X^xX^{x'}Z^zZ^{z'} = i^{xz+x'z'+2x'z}X^{x\oplus x'}Z^{z\oplus z'}$
        - Ignoring phase, the multiplication output: $P''=i^{x''z''}X^{x''}Z^{z''} \leftrightarrow (x'',z'') = (x\oplus x' , z\oplus z') = (x+x'-2xx',z+z'-2zz')$
        - And the phase will be an exponent of $i$, which is defined as $g(x,x',z,z')\in\{-1,0,1\}$. It can never be $2$.
        - So, $PP'=(i)^{g(x,z,x',z')}P''$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Single-Qubit Pauli to Bits Mapping (contd.)
    - Explicit expression of $g(x,z,x',z')$:

    $$
    \begin{align*}
    g(x,z,x',z') &= xz+x'z'+2x'z-x''z''\\
    &= xz+x'z'+2x'z-(x+x'-2xx')(z+z'-2zz')\\
    &= xz+x'z'+2x'z-xz-xz'+2xzz'-x'z-x'z'+2x'zz'+2xx'z+2xx'z'-4xx'zz'\\
    &= x'z-xz'+2xzz'+2x'zz'+2xx'z+2xx'z'-4xx'zz'\\
    &= xz'(2z-1)+x'z(2z'+1)+2xx'z-2xx'z'(2z-1)\\
    &= xz'(2z-1)(1-2x')+x'z(2z'+1+2x)\\
    &= xz'(2z-1)(1-2x')+x'z(2z'+1+2x+4xz')&[\because\bmod4]\\
    &= xz'(2z-1)(1-2x')+x'z(2z'+1)(2x+1)\\
    &= xz'(2z-1-4z)(1-2x'+4x')+x'z(2z'+1)(2x+1)&[\because\bmod4]\\
    &= xz'(-2z-1)(2x'+1)+x'z(2z'+1)(2x+1)\\
    &= -xz'(2z+1)(2x'+1)+x'z(2z'+1)(2x+1)\\
    &= x'z(2z'+1)(2x+1)-xz'(2z+1)(2x'+1)
    \end{align*}
    $$

    - It is an odd function: $g(x',z',x,z)=-g(x,z,x',z')$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## $n$-Qubit Pauli Strings to Bits Mapping
    - Extending the idea, we could map $n$-qubit Pauli strings to $2n$ bits.
    - We put all the $X$ information of each qubit first, then $Z$ information of each qubit.
      - e.g $X_1Y_2\to1101, Z_1Z_2\to0011, Y_1Z_2\to1011$  etc.
    - The question of whether two Pauli strings commute can be answered by taking a "wierd" simplectic product.
      - We switch $X$ and $Z$ information of one of the strings and then take regular binary "dot" product.
      - e.g. $X_1Y_2$ and $Y_1Z_2$ commutes:

            |Pauli String|Bit String           |Flip $X$ and $Z$ of one  |Dot Product|
            |:----------:|:-------------------:|:-----------------------:|:------------:|
            |$X_1Y_2$    |$1~1~0~1$            |                         |$1\phantom{+}1\phantom{+}0\phantom{+}1$|
            |$Y_1Z_2$    |$1~0\underline{~1~1}$|$\underline{1~1}~1~0$    |$1\phantom{+}1\phantom{+}1\phantom{+}0$|
            |Commutes.   |                     |                         |$\begin{array}{c}\hline1\oplus1\oplus0\oplus0\\=0\end{array}$|

    - Later, we will need $\pm$ signs along with the pauli strings. We could use another bit for that $(2n+1)$ bits.
      - $-X_1Y_2 \to \textcolor{#f77}{1}~1101$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## (Pauli) Stabilizer of a state
    - Unitary operator $U$ is said to _stabilize_ the state $\ket\psi$ iff $U\ket\psi=\ket\psi$. For example:
        - $Z\ket0=\ket0$
        - $(-X)\ket-=\ket-$
        - $(X_1X_2)\ket{\Phi^+} = \ket{\Phi^+}$ where $\ket{\Phi^+} = \frac{1}{\sqrt2}\ket{00}+\frac{1}{\sqrt2}\ket{11}$
    - For all intents and purposes here, we will only consider Pauli operators that stabilize a given state.
    - The set of all **Pauli group elements** that stabilizes a state is called the _Stabilizer_ of that state. For example:
        - $\stab(\ket0) = \{I,Z\}$
        - $\stab(\ket{00})=\{I_2,Z_1,Z_2,Z_1Z_2\}$
        - $\stab(\ket{\Phi^+}) = \{I_2, Z_1Z_2, X_1X_2, -Y_1Y_2\}$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Stabilizer Group
    - $\stab(\ket\psi)$ forms an (abelian) group. Because:
        - If $P$ and $Q$ stabilizes a state, then $PQ$ also stabilizes it: $PQ\ket\psi=P\ket\psi = \ket\psi$
        - If $P$ stabilizes a state, then $P^{-1}$ also stabilizes it: $P\ket\psi=\ket\psi \implies\ket\psi=P^{-1}\ket\psi$
        - $I$ stabilizes every state. So $I\in\stab(\ket\psi)$
        - The group operation matrix multiplication is associative
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Pauli Stabilizer Group Properties
    - $I$ stabilizes every state. So it is always included in $\stab(\ket\psi)$.
    - The only vector stabilized by $-I$ is the zero vector, which is not a valid state vector.
        - $(-I)\ket\psi=\ket\psi \implies \ket\psi=0$
        - So, $-I\notin\stab(\ket\psi)$ for any valid state $\ket\psi$
    - For an $n$-qubit Pauli operator $P,$ both $+P$ and $-P$ can never stabilize a state.
        - Because that would mean $(+P)(-P)=-I$ is in the stabilizer $\implies$ zero vector (invalid state)
        - So, either $+P$ or $-P$ (exclusively) stabilizes a state.
    - For an $n$-qubit Pauli operator $P,$ the operator $\pm iP$ can never stabilize a state.
        - Because that would mean $(\pm iP)^2=-I$ is in the stabilizer $\implies$ zero vector (invalid state)
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Pauli Stabilizer Group Properties (contd.)
    - Stablizer group is **abelian**. Because:
      - $P,Q\in\stab(\ket\psi) \implies PQ\in\stab(\ket\psi)\quad\textrm{and}\quad QP\in\stab(\ket\psi)$
      - Since Pauli operators either commute/anticommute, $PQ=\pm QP$.
        - But if they anticommuted, $(PQ)^2=(PQ)(-QP)=-PQ^2P=-P^2=-I$ would have been in the stabilizer.
        - So, $P$ and $Q$ must commute: $PQ=QP$.
    - If $P,Q\in\stab(\ket\psi)$, then
      - $PQ=QP$ is a stabilizer element.
      - $PQP$ is also a stabilizer. But since $P$ and $Q$ commute, $PQP = PPQ=Q$
    - The only "pure combinations" of $P$ and $Q$ are $\{I,P,Q,PQ\} = \{P^aQ^b~\forall~a,b\in\mathbb Z_2\}$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Pauli Stabilizer Group Generator
    - If combining a set of elements in different ways (using group operation) generates a group, it's called a _generator/generating set_ of that group.
        - $Z_1$ and $X_1$ generates the group $\{\pm I,\pm Z_1,\pm X_1,\pm Z_1X_1\}$
        - Notation: $\gen{Z_1, X_1} = \{\pm I,\pm Z_1,\pm X_1,\pm Z_1X_1\}$.
        - Same group can have multiple generators: $\gen{Z_1,X_1} = \gen{I,Z_1,X_1} = \gen{Z_1,-X_1} = \gen{Z_1, Z_1X_1}$
    - A _minimal generating set_ is a generating set, none of whose elements can be produced from the other elements
        - In other words, no redundant element in minimal generating set
        - $\gen{I,Z_1,X_1}$ is not a minimal generating set because $Z_1^2=I$.
        - But $\gen{Z_1,X_1}$ is because $X_1\notin\gen{Z_1}=\{I,Z_1\}$
    - Since Pauli stabilizers form an abelian group, a minimal generating set with $n$ elements will generate $2^n$ stabilzier elements.
        - Each element of the Pauli stabilizer $\gen{G_1,G_2,\cdots,G_n}$ can be written as $S=G_1^{a_{_1}}G_2^{a_{_2}}\cdots G_n^{a_{_n}}~\forall~a_k\in\mathbb Z_2.$
        - That's because of commutivity and squaring to identity.
        - Also, since minimal generating set, e.g. $G_1$ can't be made from combining other stabilizer generators $\gen{G_2, \cdots, G_n}$.
    - Any stabilizer state (ignoring global phase) can be uniquely identified using its stabilizer (equivalently its minimal generating set).
        - This is becuase of dimension theorem. Every generator cuts the state space by half.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Counting Stabilizer States
    - Explanation in next few slides
    - Number of unique $n$-qubit stabilizer states,

    $$
    % \textrm{\# of unique $n$-qubit stabilizer states}=
    N=
    2^n\prod_{k=0}^{n-1}(2^{n-k}+1)
    $$
    - $N=\dfrac GA$ where
        - Number of minimal generating sets we can make out of Pauli strings (with $\pm$ phase), $\displaystyle G=2^{{n(n+1)}/{2}}\prod_{k=0}^{n-1}(4^{n-k}-1)$
        - Number of minimal generatins sets that generate the same stabilizer group, $\displaystyle A=2^{{n(n+1)}/{2}}\prod_{k=0}^{n-1}(2^{n-k}-1)$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Counting Stabilizer States (contd.)
    - How many different $n$-qubit minimal generating set can we make? Constraints:
        - Has $n$ slots to fill: $\gen{G_1, G_2, G_3,\cdots,G_n}$
        - Forget the phases $(\pm)$ for now, just consider $n$-qubit Pauli strings: $\gen{P_1, P_2, P_3,\cdots, P_n}$
        - If we can figure out how many choices we have for $\gen{P_1, P_2, P_3,\cdots, P_n}$
            - We can take $G_k=\pm P_k$ for each $k$ and create a new combination of minimal generating set
            - This is possible because stabilizer will never include both $+P_k$ and $-P_k$.
            - Then we have $2^n$ phase choices. We multiply that with the number of choices for generator from Pauli string.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Counting Stabilizer States (contd.)
    How many choices do we have for $\gen{P_1, P_2, P_3,\cdots, P_n}$?
    - Minimal generating set can never include $I_n$ since it can be generated by any Pauli operator, $P_k^2=I_n$
    - Choose $P_1$ from set of Pauli strings. Constraints:
        - Can't be identity $I_n$.
        - Number of choices$~=4^n-1$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Counting Stabilizer States (contd.)
    How many choices do we have for $\gen{P_1, P_2, P_3,\cdots, P_n}$?
    - Choose $P_2$ from set of Pauli strings. Constraints:
      - Can't be from $\gen{P_1} = \{I_n,P_1\}$. Otherwise not minimal.
      - Must commute with $P_1$. But only half of the Pauli strings $(=4^n/2)$ commute with $P_2$. Because:
        - Map every $n$-qubit Pauli string to a $2n$-bit string of $X_i$ and $Z_j$ (ignoring phase)
        - $I\to00,~Z\to01,~X\to10,~Y\to11$
        - $X_1Y_2 \to 1101,~X_1I_2\to1000,~ Z_1Z_2\to0011,~ X_1Z_2\to1001$
        - Two $n$-qubit Pauli strings $P,P'$ will commute if single-qubit Paulis anitcommute at even number of places.
        - Let, $P_1=X_1Y_2\to1101$ and $P_2\to abcd$. Then for commutivity, we need, $b\oplus c\oplus d = 0$.
        - That means, we can choose 3 out of 4 variables freely (e.g. $a,b,c$). And choose $d=b\oplus c$ for commutativity.
        - So, $2^{2n-1}=4^n/2$ choices for commuting Pauli strings.
        - Btw, take $d=\overline{b\oplus c}$ for anticommuting strings (i.e. equal amount).
      - Number of choices$~=2^{2n-1}-2^1=\dfrac{4^n}2-2$

    <!-- ## Counting Stabilizer States (contd.)
    How many choices do we have for $\gen{P_1, P_2, P_3,\cdots, P_n}$?
    - Choose $P_2$ from set of Pauli strings. Constraints:
        - Can't be from $\gen{P_1} = \{I_n,P_1\}$. Otherwise not minimal.
        - Must commute with $P_1$. But only half of the Pauli strings $(=4^n/2)$ commute with $P_2$. Because:
            - Map every $n$-qubit Pauli string to a $2n$-bit string of $X_i$ and $Z_j$ (ignoring phase)
            - $I\to00,~Z\to01,~X\to10,~Y\to11$
            - $X_1Y_2 \to 1011,~X_1I_2\to1000,~ Z_1Z_2\to0101,~ X_1Z_2\to1001$
            - Two $n$-qubit Pauli strings $P,P'$ will commute if single-qubit Paulis anitcommute at even number of places.
            - This can be checked from bit string representation by evaluating $\displaystyle\bigoplus_{k=1}^n x_k^{} z'_k\oplus x'_k z_k^{}$, which is just binary dot product with $x$ and $z$ swapped.
            - To check for commutivity, we can just swap $x$ and $z$ of one of them and do binary dot product. For example, $X_1Y_2\to1011\to0111$ (swapped)
            - e.g. $X_1Y_2$ commutes with $Z_1Z_2$ because $0111\cdot0101=0$ but anticommutes with $X_1Z_2$ because $0111\cdot1001=1$
            - To find how many Pauli strings commute with $X_1Y_2$, all we need to do is find solutions for which $0111\cdot????=0$
            - $0111\cdot{*}???=0\to$ We can choose "$*$" to be either $0$ or $1$ (choices=2). For the bits where we have $1$'s, we need to choose even number of them.
            - We have three $1$'s here. So we have $8$ possibilities. Half of them will have even parity (commutes), other half odd parity (anticommutes)
            - By that I mean, we can take two $?$ to be either $0$ or $1$. But, the third bit has to be so that the bit string has even parity. ${*}???\to{*}{*}{*}?$
            - Alternatively, for the unknowns $a,b,c$ we have to find $0111\cdot{*}abc=0 \implies a\oplus b\oplus c=0$. We get 2 free parameters. So we have 4 choices for $(a,b,c)$.
            - Generalizing this, we get that $2^{2n-1}=4^n/2$ of the Pauli strings will commute
        - Number of choices$~=\dfrac{4^n}2-2$ -->
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Counting Stabilizer States (contd.)
    How many choices do we have for $\gen{P_1, P_2, P_3,\cdots, P_n}$?
    - Choose $P_3$ from set of Pauli strings. Constraints:
      - Can't be from $\gen{P_1, P_2} = \{I_n,P_1,P_2,P_1P_2\}$. Otherwise not minimal.
      - Must commute with $P_1$ and $P_2$. But only a quarter of the Pauli strings commute with $P_3$.
        - Similar logic to what we have done in previous slide.
        - Let, $P_1=X_1Y_2\to1101, P_2=Y_1Z_2\to1011$ and $P_3\to abcd$.
        - For commutativity with both $P_1$ and $P_2$, we need $b\oplus c\oplus d=0$ and $a\oplus b\oplus c=0$
        - Now, we have two linearly independent equations. So, we have $(2n-2)$ free variables.
        - That means, we have $2^{2n-2}$ choices for Pauli strings.
        - Crucially, $P_1, P_2$ etc. are chosen so that they are commutative and independent of each other.
          - That means all the equations are consistent (no contradiction)
          - Since independent, the equations are also linearly independent
          - We can reduce to RREF to write $k$ dependent variables in terms of other $(2n-k)$ free variables
      - Number of choices$~=2^{2n-2}-2^2=\dfrac{4^n}4-4$

    <!-- ## Counting Stabilizer States (contd.)
    How many choices do we have for $\gen{P_1, P_2, P_3,\cdots, P_n}$?
    - Choose $P_3$ from set of Pauli strings. Constraints:
        - Can't be from $\gen{P_1, P_2} = \{I_n,P_1,P_2,P_1P_2\}$. Otherwise not minimal.
        - Must commute with $P_1$ and $P_2$. But only a quarter of the Pauli strings commute with $P_3$.
            - Similar logic to what we have done in previous slide.
            - e.g. $X_1Y_2\to1011$ and $Z_1Z_2\to0101$ commute. Let's find how many operators commute with both of them.
            - For that we can look for bit strings that are orthogonal to both $0111$ and $1010$.
            - $0111$ is orthogonal to $\{{*}000,{*}011,{*}110,{*}101\}$
            - $1010$ is orthogonal to $\{0{*}0{*},1{*}1{*}\}$
            - Both is orthogonal to $\{0000,0101,1011,1110\}$.
            - These can be found by choosing bit strings in following way:
                - If the two strings $0111$ and $1010$ both had $0$'s at same position, replace with either $0$ or $1$ $(*)$.
                - In other words $0111~|~1010 = 1111\to$ If any $0$'s $\to$ replace with $*$
                - Let the bit strings be $abcd$. Then $0111\cdot abcd=0\implies b\oplus c\oplus d=0$ and $1010\cdot abcd=0\implies a\oplus c=0$
                - Two conditions mean that we have 2 free parameters out of 4. So we have $2^2=4$ choices.
            - Generalizing, while choose $P_3$, we have two conditions (due to $P_1$ and $P_2$). Other than that all parameters are free. So, $2^{2n-2}=4^n/4$
        - Number of choices$~=\dfrac{4^n}4-4$ -->
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Counting Stabilizer States (contd.)
    How many choices do we have for $\langle~G_1, G_2, G_3,\cdots,G_n~\rangle$?
    - For phases we have $2^n$ choices for each $\langle~P_1, P_2, P_3,\cdots,P_n~\rangle$
    - For each $\langle~P_1, P_2, P_3,\cdots,P_n~\rangle$, we have:
        - Choices$~=(4^n-1)\left(\dfrac{4^n}2-2\right)\left(\dfrac{4^n}4-4\right)\cdots(1)$
        - or, Choices$\displaystyle~=\prod_{k=0}^{n-1}\left(\dfrac{4^n}{2^k}-2^k\right)$
    - So, Number of generators we can make out of Pauli operators (with phase)$\displaystyle~=2^n\prod_{k=0}^{n-1}\left(\dfrac{4^n}{2^k}-2^k\right)$
    - Equivalently, $\displaystyle~=2^n\left(\prod_{k=0}^{n-1}2^k\right)\left(\prod_{k=0}^{n-1}(4^{n-k}-1)\right) = 2^n2^{\sum_{k=0}^{n-1}k}\left(\prod_{k=0}^{n-1}(4^{n-k}-1)\right) = 2^{n(n+1)/2}\left(\prod_{k=0}^{n-1}(4^{n-k}-1)\right)$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Counting Stabilizer States (contd.)
    - How many minimal generating sets can we make for a given stabilizer group?
    - For a given stabilizer $\stab(\ket\psi) = \{S_1,S_2,\cdots,S_{2^n}\}$
        - We have $2^n$ stabilizer elements.
        - Choose $G_1$ from the stabilizer group. Constraints:
            - Any stabilizer element will do except $I$.
            - Choices: $2^n-1$
        - Choose $G_2$ from the stabilizer group. Constraints:
            - Any stabilizer element will do except $\gen{G_1}=\{I,G_1\}$.
            - Choices: $2^n-2$
        - Choose $G_3$ from the stabilizer group. Constraints:
            - Any stabilizer element will do except $\gen{G_1, G_2}=\{I,G_1,G_2,G_1G_2\}$.
            - Choices: $2^n-4$
        - Choose $G_{k+1}$ from the stabilizer group. Constraints:
            - Any stabilizer element will do except $\gen{G_1,G_2,\cdots,G_k}.
            - Choices: $2^n-2^k$
    <!-- ## Counting Stabilizer States (contd.)
    - How many minimal generating sets can we make for a given stabilizer group?
    - For a given stabilizer $\stab(\ket\psi) = \langle~G_1, G_2, G_3,\cdots,G_n~\rangle$
        - We have $2^n$ stabilizer elements.
        - Each of the stabilizer elements can be written as: $G_1^{b_{_1}}G_2^{b_{_2}}G_3^{b_{_3}}\cdots G_n^{b_{_n}}$
        - Here $b_k$ are either $0$ or $1$. Because the stabilizer elements commute and Pauli operators squares to identity.
        - In the stabilizer group, we will have all $2^n$ combinations of $\overrightarrow{b} = b_1b_2b_3\cdots b_n$.
        - Then the problem of how many generating sets for a given stabilizer translates to:
            - How many ways to linearly combine $n$ number of $n$-bit strings to get all $2^n$ strings?
            - Choose first bit string $\overrightarrow{b}$ that is not all zeroes. Number of choices$~=2^n-1$
            - Choose second bit string $\overrightarrow{b'}$ that is neither all zeroes nor the last string. Number of choices$~=2^n-2$
            - Choose third bit string $\overrightarrow{b''}$ that can't be generated by linear combination of first and second bit. Choices$~=2^n-4$ -->
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Counting Stabilizer States (contd.)
    - If we continue this process, we will find that the number of ways are,
        - Number of generators that generate the same stabilizer group, $\displaystyle A=(2^n-1)(2^n-2)(2^n-4)\cdots(1)=\prod_{k=0}^{n-1}(2^n-2^k) = \left(\prod_{k=0}^{n-1}2^k\right)\prod_{k=0}^{n-1}(2^{n-k}-1)$
        - Equivalently, $\displaystyle A=2^{n(n-1)/2}\prod_{k=0}^{n-1}(2^{n-k}-1)$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Counting Stabilizer States (contd.)
    - Since the binary power logic applies to every stabilizer, except for different $G_k$,
        - We have the same number $(A)$ of minimal generating sets for every stabilizer group.
        - So, $~N=G/A$.
        - Number of unique $n$-qubit stabilizer states,

    $$N=2^n\prod_{k=0}^{n-1}(2^{n-k}+1)$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Stabilizer Simulation
    - Every stabilizer state is denoted by its minimal Pauli stabilizer generator $\ket\psi\equiv\gen{S_1,S_2,\cdots,S_n}$
      - Requires $n\cdot (2n+1) = O(n^2)$ bits.
    - Unitary gate application may result in a non-stabilizer state. So we limit ourselves to Clifford gates.
      - $\ket{\psi'}=U\ket\psi\implies U^\dag\ket{\psi'}=\ket\psi\implies US_kU^\dag\ket{\psi'}=U\ket\psi=\ket{\psi'}\implies S_k'=US_kU^\dag$
      - Output state is stabilized by $\gen{US_1U^\dag,US_2U^\dag,\cdots,US_nU^\dag}$
      - Using tableau (lookup table), this can be computed in $O(n^2)$ time.
    - Measurements (Pauli observable) can lead to two cases. But post-measurement state is always an eigenstate of $M$.
      - **`Case I`: Random Output**
        - When the Pauli Measurement $M$ does not stabilize the pre-measurement state $\ket\psi$
        - equivalently, When $M$ anticommutes with at least one of the stabilizer generator elements
        - Find the first anti-commuting stabilizer element, multiply that with all anti-commuting stab elements.
        - Replace that first anti-commuting stab element with $M$.
        - Commutativity checking can be done in $O(n)$ time. To check all $n$ stab elements, we need $O(n^2)$ time.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Stabilizer Simulation (Without Improvement) (contd.)

    - Measurements (Pauli observable) can lead to two cases. But post-measurement state is always an eigenstate of $M$.
      - **`Case 2`: Deterministic Output**
        - When the Pauli Measurement $M$ stabilizes the pre-measurement state $\ket\psi$
        - equivalently, When $M$ commutes with all of the stabilizer generator elements
        - Difficulty is finding whether $\ket\psi$ is $+1$ eigenvector of $M$ or $-1$.
          - Because if $M$ commutes with $A$, so does $-M$.
        - We need to figure out what stabilizers make $M$ or $-M$.
        - Use Gaussian elmination for that. But it requires $O(n^3)$ time.
    - This paper improved the simulation by introducing destabilizers that reduces $O(n^3)$ to $O(n^2)$.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Destabilizers
    - Along with $n$  stabilizer generators $\gen{S_1,S_2,\cdots,S_n}$, we also keep track of $n$ destabilziers $\gen{D_1,D_2,\cdots,D_n}$
    - But they satisfies the following conditions:
      - All destabilizers commute with each other: $D_jD_k=D_kD_j$
      - Corresponding stabilizers anti-commute but all others commute: $D_jS_k=(-1)^{\delta^{}_{jk}} S_kD_j$
        - Meaning, $D_kS_k=-S_kD_k$
        - And if $j\neq k,$ then $D_jS_k=S_kD_j$
      - And of course stabilizer elements commute: $S_jS_k=S_kS_j$
    - Can we always find such destabilizers?
      - No need to prove, just start from standard condition and make sure evolutions keep this invariant
    - As a consequence, any Pauli string can be decomposed into stabs and destabs
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Standard Initial Tableau
    - To keep the destabs and stabs organized in bits, we use binary matrix called Tableau
    - Every simulation will start from the standard initial state $\ket{00\cdots0}$.
        - The tableau for this state is called **standard initial tableau**.
        - The stabilizer generators are $\gen{Z_1, Z_2, \cdots, Z_n}$
        - The natural destabilizer generators are $\gen{X_1,X_2,\cdots,X_n}$
        - This is how it is written as a binary matrix (last column is for $\pm$ sign):

    $$\def\arraystretch{1.2}
    {\color{red}\begin{array}{cr}
    D_1=X_1&\longrightarrow\\
    D_2=X_2&\longrightarrow\\
    \vdots&\vdots\quad\\
    D_n=X_n&\longrightarrow\\
    \hdashline
    S_1=Z_1&\longrightarrow\\
    S_2=Z_2&\longrightarrow\\
    \vdots&\vdots\quad\\
    S_n=Z_n&\longrightarrow\\
    \end{array}}
    \mat{cccc:cccc:c}{
    \color{red}1&0&\cdots&0 &0&0&\cdots&0 &0\\
    0&\color{red}1&\cdots&0 &0&0&\cdots&0 &0\\
    \vdots&\vdots&\ddots&\vdots &\vdots&\vdots&\ddots&\vdots &\vdots\\
    0&0&\cdots&\color{red}1 &0&0&\cdots&0 &0\\
    \hdashline
    0&0&\cdots&0 &\color{red}1&0&\cdots&0 &0\\
    0&0&\cdots&0 &0&\color{red}1&\cdots&0 &0\\
    \vdots&\vdots&\ddots&\vdots &\vdots&\vdots&\ddots&\vdots &\vdots\\
    0&0&\cdots&0 &0&0&\cdots&\color{red}1 &0\\}
    \equiv
    \def\arraystretch{1.5}
    \mat{c:c:c}{
    I_{n\times n}&0_{n\times n}&0_{n\times 1}\\
    \hdashline
    0_{n\times n}&I_{n\times n}&0_{n\times 1}}
    =\mat{cc:c}{
    I&0&0\\
    % \hline
    0&I&0}$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Pauli Commutativity with Matrix Multiplication
    - To check if two Pauli operators commute, we can check the wierd binary product. e.g.
        - $X_1Y_2=\mat{cc:cc}{1&1&0&1} = \mat{c:c}{\vv{x}&\vv{z}} := P$
        - $Y_1Z_2=\mat{cc:cc}{1&0&1&1} = \mat{c:c}{\vv{x'}&\vv{z'}} := Q$
        - Also define, $P' = \mat{c:c}{\vv{z}&\vv{x}} = PL$ where $L$ is a linear operator
        - Commutes iff, $~\vv x\cdot\vv{z'}+\vv{x'}\cdot\vv z=0$
        - This dot product can also be written as, $\vv x{\vv{z'}}^\top+\vv z{\vv{x'}}^\top$
          - or, equivalently, $~\vv{z'}{\vv x}^\top+\vv{x'}{\vv{z}}^\top$
          - or, equivalently, $P' Q^\top = PLQ^\top=\mat{c:c}{\vv{z}&\vv{x}} \mat{c}{{\vv{x'}}^\top\\\hdashline{\vv{z'}}^\top}$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Pauli Commutativity with Matrix Multiplication (contd.)
    - This makes checking multiple commutativity really easy. Just stack them. e.g.
      - Check commutativity between $\{X_1Y_2,~Y_1Z_2\}$ and $\{Y_1Z_2,~Z_1Z_2,~Y_1Y_2\}$
      - $\{X_1Y_2,~Y_1Z_2\}\to
      \mat{cc:cc}{1&1&0&1\\1&0&1&1} =
      \mat{c:c}{\vv{x_1}&\vv{z_1}\\\vv{x_2}&\vv{z_2}} =
      \mat{c:c}{A&B} := P$
      - $\{Y_1Z_2,~Z_1Z_2,~Y_1Y_2\}\to
      \mat{cc:cc}{1&0&1&1\\0&0&1&1\\1&1&1&1} =
      \mat{c:c}{\vv{x'_1}&\vv{z'_1}\\\vv{x'_2}&\vv{z'_2}\\\vv{x'_3}&\vv{z'_3}} =
      \mat{c:c}{A&B} := Q$
      - Again, $P'Q^\top = PLQ^\top$ gives us all the commutativity information.
        - $PLQ^\top = \mat{cc:cc}{0&1&1&1\\1&1&1&0}
          \mat{ccc}{1&0&1\\0&0&1\\\hdashline1&1&1\\1&1&1} =
          \mat{ccc}{0&0&1\\0&1&1}.$
        - If the value in $r$-th row and $c$-th column is $0$, then
          - $r$-th element of $P$ and $c$-th element of $Q$ commutes.
          - Otherwise if 1, they anti-commute
          - e.g. first row last column being 1 says $X_1Y_2$ and $Y_1Y_2$ anti-commutes.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Tableau Condition
    - Every tableau can be written as binary matrices as before. Often times the last column for sign will be omitted.
    - A tableau, $T=\mat{}{A&B\\C&D}$ must satisfy the following:
    - Stabilizers must commute. So,
      $\mat{}{D&C}
      \mat{}{C^\top\\D^\top} =
      DC^\top+CD^\top=0$
    - Destabilizers must also commute. So,
      $\mat{}{B&A}
      \mat{}{A^\top\\B^\top} =
      BA^\top+AB^\top=0$
    - Stabilizers and destabilizers mostly commute, but anticommute at matching indices.
      - So,
      $\mat{}{B&A}
      \mat{}{C^\top\\D^\top} =
      BC^\top+AD^\top=I$
      - Or, equivalently,
      $\mat{}{D&C}
      \mat{}{A^\top\\B^\top} =
      DA^\top+CB^\top=I$
        - which is just transpose of previous equation

    - All these information can be written using one equation:
      - $TLT^\top =
        \mat{}{B&A\\D&C}
        \mat{}{A^\top&C^\top\\B^\top&D^\top} =
        \mat{}{BA^\top+AB^\top&BC^\top+AD^\top\\DA^\top+CB^\top&DC^\top+CD^\top} =
        \mat{}{0&I\\I&0}
        .$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Important Consequences (Invariants)
    - The tableau matrix always has an inverse.
        - $TT^{-1} =
        \mat{}{A&B\\C&D}
        \mat{}{D^\top&B^\top\\C^\top&A^\top} =
        \mat{}{AD^\top+BC^\top&AB^\top+BA^\top\\CD^\top+DC^\top&CB^\top+DA^\top} =
        \mat{}{I&0\\0&I} =
        I_{(2n\times2n)}$
    - So, $T$ must be a **full rank** matrix.
    - That means, any binary row vector can be written as linear combinations of rows.
    - Implying, any Pauli string can be written as multiplication of the stabs and destabs (ignoring phase).
    - So, $\{D_j\}\cup\{S_k\}$ generates the set of all Pauli strings upto phase.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Clifford Evolution on Tableau
    ## New Tableau After Applying $U$
    - Given a state by its stab gen $\gen{S_1,S_2,\cdots,S_n}\mapsto\gen{US_1U^\dag,US_2U^\dag,\cdots,US_nU^\dag}$
    - We also want to keep the property of destabilizers commute with all stabilizers except matching indices.
    - So, for a tableau, $\gen{D_1,D_2, \cdots, D_n, S_1, S_2, \cdots S_n}$ we should also modify destabilizers in similar manner.
      - $D_jD_k=D_kD_j,~D_jS_k=(-1)^{\delta_{jk}}S_kD_j$ and $S'_k=US_kU^\dag$
      - We propse $D_j'=UD_jU^\dag$. Because,
        - $D'_jD'_k = UD_jU^\dag UD_kU^\dag=UD_jD_kU^\dag=UD_kD_jU^\dag=UD_kU^\dag UD_jU^\dag=D'_kD'_j$
        - $D'_jS'_k = UD_jU^\dag US_kU^\dag=UD_jS_kU^\dag=(-1)^{\delta_{jk}}US_kD_jU^\dag=(-1)^{\delta_{jk}}US_kU^\dag UD_jU^\dag=(-1)^{\delta_{jk}}S'_kD'_j$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## New Tableau After Applying $U$ (contd.)
    - Since every Pauli operator can be decomposed into $X$'s and $Z$'s, we only need to know how they change those.
      - For single qubit $U$ and Pauli operators,
        - Here Pauli stabilizer $P$ with phase $(-1)^r$ can be written as $P=(-1)^ri^{xz}X^xZ^z$. Then,
        - $UPU^\dag=U((-1)^ri^{xz}X^xZ^z)U^\dag=(-1)^ri^{xz}UX^x(U^\dag U)Z^zU^\dag = (-1)^ri^{xz}(UX^xU^\dag)(UZ^zU^\dag) = (-1)^ri^{xz}(UXU^\dag)^x(UZU^\dag)^z$
        - Since $U$ is Clifford, $UXU^\dag$ and $UZU^\dag$ will also be Pauli. Merge them into one Pauli again. (see $H$ application)
        - Careful. $(UXU^\dag)^x$ and $(UZU^\dag)^z$ may introduce phase which will be added to $r$ (depending on $x$ and $z$).
        - So, all we need to know is $UXU^\dag$ and $UZU^\dag$.
      - Even for multi-qubit $U$ and Pauli strings, we can take similar approach.
        - For example, a two-qubit Puali, $P=(-1)^ri^{x_1z_1+x_2z_2}X_1^{x_1}Z_1^{z_1}X_2^{x_2}Z_2^{z_2}$
        - This means we need to know $UX_1U^\dag, UZ_1U^\dag, UX_2U^\dag$ and $UZ_2U^\dag$
      - If a stab is on a different qubit that where $U$ is being applied, it has no effect.
        - For example, $U_1X_2U_1^\dag=(U\otimes I)(I\otimes X)(U^\dag\otimes I)=(UU^\dag\otimes X)=X_2$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## New Tableau After Applying $H$
    - If applied hadamard, we get,
      -  $HXH^\dag=Z$ and $HZH^\dag=X$
      -  That means, if applied on a single qubit Pauli stabilizer (for simplicity),
        - $P=(-1)^ri^{xz}X^xZ^z\to\mat{cc:c}{x&z&r}$
        - If $R$ is a Pauli string  without phase where $R=$
               <br>$\begin{aligned} HPH^\dag&=(-1)^ri^{xz}HX^xZ^zH^\dag\\
              &=(-1)^ri^{xz}(HXH^\dag)^x(HZH^\dag)^z\\
              &=(-1)^ri^{xz}Z^xX^z\\
              &=(-1)^ri^{xz}(-1)^{xz}X^zZ^x\\
              &=(-1)^{r\oplus xz}i^{zx}X^zZ^x\\
              &=(-1)^{r\oplus xz}R
              & \textrm{where}~R=i^{zx}X^zZ^x\to\mat{cc:c}{z&x&0}\\
              &=Q
              & \textrm{where}~Q=(-1)^{r\oplus xz}R\to\mat{cc:c}{z&x&r\oplus xz}\\
              \end{aligned}$
        - In summary, $P=\mat{cc:c}{x&z&r}\longmapsto
           \mat{cc:c}{z&x&r\oplus xz}=Q$
      - This means, applying $H$ on a tableau essentially swaps $X$ and $Z$ columns.
      - And flips $r$ column if $xz=1$. Meaning if the Pauli operation was $Y$.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## New Tableau After Applying $H$ (contd.)
    - If we apply $H$ on the $a$-th qubit, this would only affect the $a$-th columns of $X$ and $Z$; and optionally affects phase.
    - This tableau transformation is a linear transformation:

    $$T\longmapsto TL_H
    = T\mat{c:c}{I-\Pi_a&\Pi_a\\\hdashline\Pi_a&I-\Pi_a}
    = T\mat{c:c}{I\oplus\Pi_a&\Pi_a\\\hdashline\Pi_a&I\oplus\Pi_a}$$
    - In summary, $\mat{c:c}{x&z}
    \longmapsto\mat{c:c}{z&x}$
    and $r\longmapsto r\oplus xz$

    <center><img src="public/hadamard.drawio.svg"/></center>
    """)
    return


@app.cell
def _(mo):
    _title = mo.md("## New Tableau After Applying $S$")

    _left = mo.md(r"""
    - $SXS^\dag=Y$ and $SZS^\dag=Z$. That means,

    $$\begin{align*}
    P&=(-1)^ri^{xz}X^xZ^z\longmapsto (-1)^ri^{xz}Y^xZ^z\\
    &=(-1)^ri^{xz}i^xX^xZ^xZ^z\\
    &=(-1)^ri^{x+xz}X^xZ^{x\oplus z}\\
    &=(-1)^ri^{x+xz}i^{-x(x\oplus z)}i^{x(x\oplus z)}X^xZ^{x\oplus z}\\
    &=(-1)^ri^{x+xz}i^{-x(x+z-2xz)}Q 
    & \textrm{where}~Q=i^{x(x\oplus z)}X^xZ^{x\oplus z}\\
    &=(-1)^ri^{x+xz-x^2-xz+2x^2z}Q\\
    &=(-1)^ri^{x+xz-x-xz+2xz}Q\\
    &=(-1)^ri^{2xz}Q\\
    &=(-1)^r(-1)^{xz}Q = (-1)^{r\oplus xz}Q\\
    \end{align*}$$

    - In summary, 
      - $\mat{c:c}{x&z}
    \longmapsto\mat{c:c}{x&x\oplus z}$
      - $r\longmapsto r\oplus xz$

    - This tableau transformation is a linear transformation: $T\longmapsto TL_S =
    T\mat{c:c}{I&\Pi_a\\\hdashline0&I}$

    """)
    _right = mo.image(src="public/phase.drawio.svg")

    _left = mo.vstack((_left,))
    _content = mo.hstack((_left, _right), justify="start")
    mo.vstack((_title, _content), justify="start")
    return


@app.cell
def _(mo):
    _title = mo.md("## New Tableau After Applying $CX$")

    _left = mo.md(r"""
    - Here $a$-th qubit is the control and $b$-th qubit is target.
    - $CX_{ab}X_aCX_{ab}^\dag=X_aX_b,\quad CX_{ab}X_bCX_{ab}^\dag=X_b,\quad CX_{ab}Z_aCX_{ab}^\dag=Z_a\quad$ and $\quad CX_{ab}Z_bCX_{ab}^\dag=Z_aZ_b$
    - We can do similar calculations to find $CX_{ab}P_aP_bCX_{ab}^\dag$ using above results.

    - In summary, 
      - $\mat{cc:cc}{x_a&x_b&z_a&z_b}
    \longmapsto\mat{cc:cc}{x_a&x_a\oplus x_b&z_a\oplus z_b&z_b\\}$
      - $r\longmapsto r\oplus x_az_b(x_b\oplus z_a\oplus1)$

    - This tableau transformation is a linear transformation: 

    $$T\longmapsto TL_{CX} =
    T\mat{c:c}{I+\ket{a}\!\!\bra{b}&0\\\hdashline0&I+\ket{b}\!\!\bra{a}} =
    T\mat{c:c}{J&0\\\hdashline0&J^\top}
    \textrm{where}~J^2=I$$

    - Since $J^2=I\implies J=J^{-1}$, we could have also written, *(this version will seem handy later on)*

    $$T\longmapsto TL_{CX}=T\mat{c:c}{J^{-1}&0\\\hdashline0&J^\top}\textrm{where}~J^2=I$$

    """)
    _right = mo.image(src="public/cnot.drawio.svg")

    _left = mo.vstack((_left,))
    _content = mo.hstack((_left, _right), justify="start")
    mo.vstack((_title, _content), justify="start")
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## New Tableau After Applying $Z=S^{\small2}$
    - After applying $S$ once:
      - $\mat{c:c}{x&z}
    \longmapsto\mat{c:c}{x&x\oplus z}$
      - $r\longmapsto r\oplus xz$
        - or, $\quad r'=r\oplus xz$
    - After applying $S$ again:
      - $\mat{c:c}{x&x\oplus z}
    \longmapsto\mat{c:c}{x&x\oplus x\oplus z}
    = \mat{c:c}{x&z}$
      - $r''=r'\oplus x'z'=(r\oplus xz)\oplus (x(x\oplus z)) =r\oplus xz \oplus x^2\oplus xz=r\oplus x$
      - $r\oplus xz\longmapsto r\oplus x$
    - In summary,
      - $\mat{c:c}{x&z}
    \longmapsto\mat{c:c}{x&z}$
      - $r\longmapsto r\oplus x$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## New Tableau After Applying $X=HZH$
    - After applying $HZH$:

    $$\begin{gather*}
    \mat{c:c}{x&z}
    &\overset H\longmapsto
    &\mat{c:c}{z&x}
    &\overset Z\longmapsto
    &\mat{c:c}{z&x}
    &\overset H\longmapsto
    &\mat{c:c}{x&z}\\
    r
    &\overset H\longmapsto
    &r\oplus xz
    &\overset Z\longmapsto
    &r\oplus xz\oplus z
    &\overset H\longmapsto
    &r\oplus xz\oplus z\oplus xz\\
    &&&&&&=r\oplus z
    \end{gather*}$$

    - In summary,
      - $\mat{c:c}{x&z}
      \longmapsto\mat{c:c}{x&z}$
      - $r\longmapsto r\oplus z$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Measurement
    - In stabilizer circuits there could be two types of measurement outcome
      - **Case I:** Random outcome with probability $\frac12$.
      - **Case II:** Deterministic outcome with probability $1$.
    - Random outcome scenario is relatively easy to handle.
    - But if the post-measurement state is an eigenvector of the measurement operator $M$,
      - $+M$ or $-M$ is in the stabilizer (exclusive).
      - But commutativity does not depend on global phase
      - For that we need to decompose $M$ into stabilizer generators $M=\prod_k S_k^{a_k}$.
        - First way: Do Gaussian Elimination $O(n^3)$
        - Second way: Use Destabilizers $O(n^2)$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Measurement (Case I: Random)
    - If $M$ anti-commutes with at least one of the stabilizers, it can't be in the stabilizer.
      - Therefore, output must be out side the stabilized subspace.
      - Since we are only considering $Z$-basis measurement on $a$-th qubit $M=Z_a$.
        - Which means, commutativity with row $R$ can be easily checked by checking if $X_a=0/1$ of row $R$.
    - The probability of measuring $\pm1$ in the measurement of $M$ is $\frac12$,
      - $P(+1) = \Braket{\psi|\Pi_M^+|\psi} = \Braket{\psi|\dfrac{I+M}{2}|\psi}$
      - $P(-1) = \Braket{\psi|\Pi_M^-|\psi} = \Braket{\psi|\dfrac{I-M}{2}|\psi}$
      - Say $S_p$ is one stabilizer element $M$ anticommutes with
        -  $S_pM=-MS_p$
      -  Then, $P(+1)
        =\Braket{\psi|\dfrac{I+M}{2}|\psi}
        =\Braket{\psi|\dfrac{I+M}{2}S_p|\psi}
        =\Braket{\psi|\dfrac{S_p+MS_p}{2}|\psi}\\
        =\Braket{\psi|\dfrac{S_p-S_pM}{2}|\psi}
        =\Braket{\psi|S_p\dfrac{I-M}{2}|\psi} = P(-1)$
      - Therefore, $P(+1)=P(-1)=\frac12$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Measurement (Case I: Random) (contd.)
    - Without destabilizer method:
      - For every stabilizer element $S_k$,
        - If $S_k$ commutes with $M$ keep it as it is.
        - If $S_k$ anti-commutes with $M$ and $j\neq k$, replace $S_k$ with $S_pS_k$.
        - Finally randomly replace $S_p$ with $M=\pm Z_a$ (whichever random eigenvector you want).
    - With destabilizer, additionally,
      - Replace $D_j$ with $S_p$. Since $M$ anti-commutes with $S_p$.
        <!-- - So, updated $D_j'=S_p$ and $S_p'=\pm M$ anticommutes. -->
      - Similary replace destablizers with $S_pD_j$.
    - Since $M=\pm Z_a$, commutativity can be checked by checking if $a$-th qubit has any $X$ component.
      -  $x_{ka}$ is the bit representing $X$ component on the $a$-th qubit of $k$-th stabilizer
      -  $x_{ja}$ is the bit representing $X$ component on the $a$-th qubit of $j$-th destabilizer
      - $\displaystyle S_k'=\begin{cases}\pm Z_a&\textrm{if}~k=p\\S_p^{x_{_{ka}}}S_k&\textrm{if}~k\neq p\end{cases}$
      - $\displaystyle D_j'=\begin{cases}S_p&\textrm{if}~j=p\\S_p^{x_{_{ja}}}D_j&\textrm{if}~j\neq p\end{cases}$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Measurement (Case I: Random) (contd.)
    - Old conditions: $[D_j,D_k]=[S_j,S_k]=0,~D_jS_k=(-1)^{\delta_{jk}}S_kD_j$ and $MS_p=-S_pM$.
    - New stabilizers commute: $S_j'S_k'=S_k'S_j'$
      - $(j=p=k)\implies$ Trivial.
      - $(j\neq p\neq k)\implies S_j'S_k'
        =(S_p^{x_{_{ja}}}S_j)(S_p^{x_{_{ka}}}S_k)
        =(S_p^{x_{_{ka}}}S_k)(S_p^{x_{_{ja}}}S_j)
        =S_k'S_j'$
      - $(j=p\neq k)\implies S_p'S_k'
        =M(S_p^{x_{_{ka}}}S_k)
        = (-S_p)_{\phantom|}^{x_{_{ka}}}MS_k
        =(-S_p)_{\phantom|}^{x_{_{ka}}}(-1)_{\phantom|}^{x_{_{ka}}}S_kM
        = S_p^{x_{_{ka}}}S_kM = S_k'S_p'$
    - New destabilizers commute: $D_j'D_k'=D_k'D_j'$
      - $(j=p=k)\implies$ Trivial.
      - $(j=p\neq k)\implies D_p'D_k'
        =S_p(S_p^{x_{_{ka}}}D_k)
        = S_p^{x_{_{ka}}}S_pD_k
        = S_p^{x_{_{ka}}}D_kS_p = D_k'D_p'$
      - $(j\neq p\neq k)\implies D_j'D_k'
        =(S_p^{x_{_{ja}}}D_j)(S_p^{x_{_{ka}}}D_k)
        =(S_p^{x_{_{ka}}}D_k)(S_p^{x_{_{ja}}}D_j)
        =D_k'D_j'$
    - Stabilizers and destabilizers commute except at matching indices: $D_j'S_k'=(-1)^{\delta_{jk}}S_k'D_j'$
      - $(j=p=k)\implies D_p'S_p' = S_p M = -MS_p = -S_p'D_p'$
      - $(j=p\neq k)\implies D_p'S_k'
        =S_p(S_p^{x_{_{ka}}}S_k)
        = S_p^{x_{_{ka}}}S_pS_k
        = S_p^{x_{_{ka}}}S_kS_p = S_k'D_p'$
      - $(j\neq p=k)\implies D_j'S_p'
        =(S_p^{x_{_{ja}}}D_j)M
        =S_p^{x_{_{ja}}} \left((-1)_{\phantom|}^{x_{_{ja}}} MD_j\right)
        =(-1)_{\phantom|}^{x_{_{ja}}} S_p^{x_{_{ja}}} MD_j
        =(-1)_{\phantom|}^{x_{_{ja}}}\left((-1)_{\phantom|}^{x_{_{ja}}} M S_p^{x_{_{ja}}}\right) D_j
        =S_p'D_j'$
      - $(j\neq p\neq k)\implies D_j'S_k'
        =(S_p^{x_{_{ja}}}D_j)(S_p^{x_{_{ka}}}S_k)
        =S_p^{x_{_{ja}}}S_p^{x_{_{ka}}}D_jS_k
        =S_p^{x_{_{ja}}}S_p^{x_{_{ka}}}(-1)^{\delta_{jk}}S_kD_j
        =(-1)^{\delta_{jk}}(S_p^{x_{_{ka}}}S_k)(S_p^{x_{_{ja}}}D_j)
        =(-1)^{\delta_{jk}}S_k'D_j'$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Measurement (Case II: Deterministic)
    - Either $+Z_a$ is in the stabilizer or $-Z_a$ is in the stabilizer (exclusively).
      - Let that be $M=(-1)^mZ_a$. Our goal is to figure out $m$.
    - Then, we can decompose it into generators, $\displaystyle M = \prod_kS_k^{c_{_k}}$ for some $c_k\in\{0,1\}$.

    $$
    \begin{align*}
    &&\prod_kS_k^{c_{_k}}&=(-1)^mZ_a\\
    \implies&& D_j\prod_kS_k^{c_{_k}}&=(-1)^mD_jZ_a\\
    \implies&& \prod_{k\neq j}S_k^{c_{_k}}D_jS_j^{c_{_j}}&=(-1)^mD_jZ_a\\
    \implies&& \prod_{k\neq j}S_k^{c_{_k}}(-1)^{c_{_j}}S_j^{c_{_j}}D_j&=(-1)^m(-1)^{x_{_{ja}}}Z_aD_j\\
    \implies&& (-1)^{c_{_j}}\prod_kS_k^{c_{_k}}D_j&=(-1)^{x_{_{ja}}}(-1)^mZ_aD_j\\
    \implies&& (-1)^{c_{_j}}MD_j&=(-1)^{x_{_{ja}}}MD_j\\
    && \therefore c_j&=x_{ja}.\\
    \end{align*}
    $$

    - In other words, stabilizers corresponding to destabilizers whose $X$ component is $1$, is necessary to make $M$.
      -  $\displaystyle M=\prod_{k\in F} S_k$ where $F=\Set{j|x_{ja}=1\textrm{ and }D_jS_k=-S_kD_j}$
      -  Multiply them to find the phase. Iff phase $m=0$, then the post-measurement state is the $+1$ eigenvector.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Row Multiplication in Tableau: `rowsum(h,i)`
    - Basically $R_h := R_i R_h$
    - Essentially add rows (mod 2).
      - $\quad\text{row}_h \mathrel\oplus= \text{row}_i$
    - For the phase information, we need the $g(x,z,x',z')$ lookup table.
    - Can be done in $O(n)$ times.
    - Let, $R_i=(-1)^{r_{_i}}P_1P_2\cdots P_n$ and $R_h=(-1)^{r_{_h}}P_1'P_2'\cdots P_n'$. Then,

    $$\begin{align*}
    R_iR_h
    &= (-1)^{r_{_i}}(P_1P_2\cdots P_n)(-1)^{r_{_h}}(P_1'P_2'\cdots P_n')\\
    &= (-1)^{r_{_i}+r_{_h}}P_1P_1'P_2P_2'\cdots P_nP_n'\\
    &= (i)^{2r_{_i}+2r_{_h}}P_1P_1'P_2P_2'\cdots P_nP_n'\\
    &= (i)^{2r_{_i}+2r_{_h}}\cdot i^{g\left(P_1,~P_1'\right)}P_1''\cdot i^{g\left(P_2,~P_2'\right)}P_2''\cdots i^{g\left(P_n,~P_n'\right)}P_n''
    &\textrm{where~~}i^{g\left(P,~Q\right)}P''=PQ\\
    &= (i)^{2r_{_i}+2r_{_h}+\sum_kg\left(P_k,~P_k'\right)}\cdot P_1''\cdot P_2''\cdots P_n''\\\\
    \therefore r_h:=&\begin{cases}
    0 & \textrm{if}~~2r_i+2r_h+\sum_k g(P_k, P_k')\equiv 0 \pmod4\\
    1 & \textrm{if}~~2r_i+2r_h+\sum_k g(P_k, P_k')\equiv 2 \pmod4
    \end{cases}\\
    x_h:=&x_i\oplus x_h
    \qquad\textrm{and}\qquad
    z_h:=z_i\oplus z_h
    \end{align*}
    $$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Tableau and Stabilizer Circuit Equivalence
    - While stabilizers alone can uniquely represent a state, including destabilizers holds more information.
    - This extra information can be used to uniquely represent a circuit (starting from standard initial tableau).
    - Stabilizers alone don't hold circuit information. e.g. $\ket0\mapsto I\ket0$ and $\ket0\mapsto S\ket0$ has same stabilizer $\gen{Z_1}$. But $I\not\equiv S$.
      - You may check that here destabilizers are different: $X_1$ vs $Y_1$. Which signifies that the circuits are not equivalent.
    - **Lemma 5:** $~\boxed{C_1\equiv C_2~\iff~T_1=T_2}$ where,
      - $C_1$ and $C_2$ be two unitary stabilizer circuits (Clifford with no measurement)
      - $T_1$ and $T_2$ be the final tableaus (including phase info) after applying $C_1$ and $C_2$ on standard initial tableau.
      - **Proof** of $C_1\equiv C_2\implies T_1=T_2:\quad$ Trivial.
      - **Proof** of $T_1=T_2\implies C_1\equiv C_2:\quad$
        - Two circuits are equivalent iff both of them map all the stabilizer states to same states $C_1\ket\psi=C_2\ket\psi$.
          - This is true because stabilizer states include all computational basis states.
        - Since every stabilizer state $\ket\psi$ can be equivalently represented by its stabilizer $\gen{S_1,S_2,\cdots,S_n}$,
          - It suffices to show that $\gen{C_1S_1C_1^\dag,C_1S_2C_1^\dag,\cdots,C_1S_nC_1^\dag} = \gen{C_2S_1C_2^\dag,C_2S_2C_2^\dag,\cdots,C_2S_nC_2^\dag}$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Tableau and Stabilizer Circuit Equivalence (contd.)
    - **Proof** of $T_1=T_2\implies C_1\equiv C_2:\quad$ (contd.)
      - Each row of $T_1=T_2$ records how $C_1$ and $C_2$ conjugate $X_k$ and $Z_k$.
        - Destabilizer rows of the tableau represent the output of $C_1X_kC_1^\dag=C_2X_kC_2^\dag$
          - Because the initial tableau destablizers contain $X_k$ at every qubit individually.
          <!-- - which is the output of $C_1$ and $C_2$ acting on $X_k$ (destab of initial tableau). -->
        - Stabilizer rows of the tableau represent the output of $C_1Z_kC_1^\dag=C_2Z_kC_2^\dag$
          - Because the initial tableau stablizers contain $Z_k$ at every qubit individually.
          <!-- - which is the output of $C_1$ and $C_2$ acting on $Z_k$ (stab of initial tableau). -->
      - Any arbitrary Pauli can be broken down to $X_k$ and $Z_k$. So we can find conjugation of any Pauli.
        - e.g if $C_1PC_1^\dag = Q$ and $C_1P'C_1^\dag = Q'$, then $C_1PP'C_1^\dag = QQ'$.
      - Since $T_1=T_2$, the rows of are equal. Hence, they map same input Pauli to the same output Pauli.
      - Any stabilizer state $\ket\psi$ that has a stabilizer $\gen{S_1,S_2,\cdots,S_n}$, then,
        - $C_1\ket\psi$ has stabilizer $\gen{C_1S_1C_1^\dag,C_1S_2C_1^\dag,\cdots,C_1S_nC_1^\dag}$
        - $C_2\ket\psi$ has stabilizer $\gen{C_2S_1C_2^\dag,C_2S_2C_2^\dag,\cdots,C_2S_nC_2^\dag}$
        - But since $C_1S_kC_1^\dag=C_2S_kC_2^\dag$, the stabilizer is the same group. So, $C_1\ket\psi=C_2\ket\psi$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Hadamard to Full-Rank $X$ Submatrix of Stabilizers
    - **Lemma 6:** For any stabilizer state, we can apply Hadamard gates on some of the qubits,
      - So that, the $X$ submatrix of stabilizers becomes full rank. i.e. every stabilizer has at least one $X$ or $Y$ in it.
        - e.g. Initial tableau has rank-$0$ $X$ submatrix of stabilizers because the state is $\ket{00\cdots0}$.
        - But we can apply $H$ on all qubits to make the state $\ket{{+}{+}\cdots{+}}$ which have identity for  $X$ submatrix (full-rankn).
    - **Proof:** Suppose the $X$ submatrix have rank $k$. The submatrix is of size $(n\times2n)$.
      - Since row additions only multiplies the stabilizers and doesn't change the state,
        - We can do row additions (Gaussian elimination) to make the submatrix as follows, where $\rank(A)=k:$

        $$\mat{c:c}{A_{(k\times n)}&B_{(k\times n)}\\
        0_{(n-k)\times n}&C_{(n-k)\times n}}_{\mathrlap{(n\times2n)}}$$

      - Since the stabilizer generators are independent, the stabilizer submatrix must have rank $n$ (otherwise dependent).
        - That means, $\rank(C)=(n-k).$ We swap qubits to make $C_2$ full rank, $\rank(C_2)=(n-k)$:

        $$\mat{cc:cc}{
        \smash{\overbrace{A_1}^k}
        &\smash{\overbrace{A_2}^{n-k}}
        &\smash{\overbrace{B_1}^k}
        &\smash{\overbrace{B_2}^{n-k}}\\
        0&0&C_1&C_2}
        {\color{cy}
        \begin{array}{l}
        \}\scriptsize~k\\
        \}\scriptsize~n-k
        \end{array}}$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Hadamard to Full-Rank $X$ Submatrix of Stabilizers (contd.)
    - **Proof:** (contd.)
      - Next, we do Gaussian elimination on bottom $(n-k)$ rows to make $C_2\mapsto I$.

        $$\mat{cc:cc}{
        \smash{\overbrace{A_1}^k}
        &\smash{\overbrace{A_2}^{n-k}}
        &\smash{\overbrace{B_1}^k}
        &\smash{\overbrace{B_2}^{n-k}}\\
        0&0&D&I}
        {\color{cy}
        \begin{array}{l}
        \}\scriptsize~k\\
        \}\scriptsize~n-k
        \end{array}}$$

      - Note that commutativity between top $k$ stabs and bottom $(n-k)$ stabs imply,

        $$A_1D^\top+A_2I+0B_1^\top+0B_2^\top=0\implies A_2=A_1D^\top$$

      - That means, the $X$ submatrix is,

        $$\mat{cc}{
        A_1 & A_2\\
        0 & 0}
        =
        \mat{cc}{
        A_1 & A_1D^\top\\
        0 & 0}
        =
        \mat{cc}{
        A_1\\
        0}
        \mat{cc}{
        I&D^\top}$$

      - Since the $X$ submatrix has rank $k$, we must have,

        $$\rank(A_1)=k$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Hadamard to Full-Rank $X$ Submatrix of Stabilizers (contd.)
    - **Proof:** (contd.)
      - Next, we apply Hadamard on the last $(n-k)$ qubits. So the $X$ and $Z$ columns are swapped.

        $$\mat{cc:cc}{
        \smash{\overbrace{A_1}^k}
        &\smash{\overbrace{B_2}^{n-k}}
        &\smash{\overbrace{B_1}^k}
        &\smash{\overbrace{A_2}^{n-k}}
        \\
        0&I&D&0}
        {\color{cy}
        \begin{array}{l}
        \}\scriptsize~k\\
        \}\scriptsize~n-k
        \end{array}}$$

      - As seen from the above matrix, the $X$ submatrix of the stabilizer is now full-rank.

        $$\boxed{\rank(X_\text{sub})=n}$$

      - While this algorithm requires Gaussian elimination and swapping qubits,
        - We actually never need to swap the qubits. It was just for our convenience.
        - Gaussian elimination requires $O(n^3)$ operations. But,
          - That is the cost for determining where the Hadamard goes.
          - Not the cost of actual circuit complexity.
        - At the end of the day we only need at most a single Hadamard per qubit.
          - So, the output hadamard circuit depth is 1 and hence, circuit depth is $O(1)$.
          - But for gate count, we need $O(n)$ gates for this step.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Decomposing Symmetric Binary Matrix
    - **Lemma:** Any symmetric binary matrix $A$ can be written as $A=\Lambda+MM^\top$, where,
      - $\Lambda$ is a diagonal binary matrix.
      - $M$ is an invertible binary matrix.
    - **Proof:** (elegant and short proof strategy suggested by Gemini. cross-check if correct?)
      - We will try to show that there exists an invertible operation $E$ such that, $E(A+\Lambda)E^T=I$.
      - We can do gaussian elimination by row addition from top to bottom (and column addition from left to right).
        - We always choose diagonal entries as pivot, and remove $1$ from lower rows.
        - If at any time pivot is $0$, we use our freedom of choosing $\Lambda$ entries.
        - The row/column additions are invertible. In fact $E_k^{-1}=E_k$. So the overall operation is also invertible.
        - We also mirror the same operation with columns.

            $$A+\Lambda\xrightarrow{\quad E_1\quad}
            \underbrace{E_1}_{\textrm{row op}}(A+\Lambda)\underbrace{E_1^\top}_{\textrm{col op}}
            \xrightarrow{\quad E_2\quad}
            E_2E_1(A+\Lambda)E_1^\top E_2^\top
            \longrightarrow \cdots$$
        - If $B$ is a symmetric matrix, then $E_kBE_k^\top$ is also symmetric.
        - If $D_{aa}$ is a matrix with a single $1$ on it's diagonal at row/column $a$, then,
          - Any prior operations (row/column $k<a$) wouldn't have changed it. So, $E_kD_{aa}E_k^\top = D_{aa}$
        - So, we can add $1$'s in $\Lambda$ as needed (when pivot is $0$).
          - Since prior operations keep the diagonal as it is, we can insert it inside the bracket. e.g.

            $$E_1AE_1^\top+D_{22} = E_1(A+D_{22})E_1^\top$$
      - By choosing $\Lambda$ this way, it is possible to end up at $I$. Then, set $M^{-1}=E_n\cdots E_2E_1$

        $$(E_n\cdots E_2E_1)\left(A+\sum_kD_{kk}\right)(E_n\cdots E_2E_1)^\top=M^{-1}(A+\Lambda)(M^{-1})^\top = I\implies A+\Lambda=MM^\top$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Decomposing Symmetric Binary Matrix (contd.)
    - **Proof:** (paper's approach)
      - Let $M$ be a lower triangular matrix with all diagonal elements being 1.
      - $M=\mat{c}{1&0&0&\cdots&0\\ \star&1&0&\cdots&0\\ \star&\star&1&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&0\\ \star&\star&\star&\cdots&1}
      \qquad\longrightarrow\qquad
      \begin{cases}
      M_{rc}=1&\textrm{if}&r=c\\
      M_{rc}=0&\textrm{if}&r<c\\
      M_{rc}=0/1&\textrm{if}&r>c
      \end{cases}$
      - Since $M$ is full-rank, $M$ is invertible.
      - We will show that there always exists a $\Lambda$ such that, $A+\Lambda=MM^\top$.
      - Note that all three of the matrices, $A,\Lambda$ and $MM^\top$ are symmetric.
      - Since off-diagonal elements of $\Lambda$ are zero, and all of them are symmetric,
        - Off-diagonal elements of $A$ must match $MM^\top$
        - Only matching upper triangular is enough.

            $$A_{ij}=\sum_k M_{ik}M_{jk}\textrm{~~where~~}i>j$$
      - Next, we use induction to prove this...
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Canonical Form
    - **Theorem:** Every unitary stabilizer circuit has a canonical form that consists of 11 rounds of $H,S,CX$ in the following sequence:

        $$\boxed{H\to CX\to S\to CX\to S\to CX\to H\to S\to CX\to S\to CX}$$

      - Shouldn't the order be actually reversed??
    - At the start, we are given the $2n\times(2n+1)$ tableau $T$ of a clifford circuit (including phase information).
      - Our goal is to use the gates to convert it back to initial tableau.
      - Since every unitary is invertible, we will have an equivalent unitary circuit, but in the canonical form.
    - $(1.~H)$ Ignoring phase, we apply $H$ to make the following $C$ submatrix full-rank (using lemma).

        $$T^{(1)}=\mat{c:c}{A&B\\\hdashline C& D}_{2n\times2n}$$
    - $(2.~CX)$ Ignoring phase, we apply $CX$ gates to perform gaussian elimination on $C$ submatrix.
      - We don't do row swapping/addition during Gaussian elim, since that may change the table to a non-equivalent circuit.

        $$T^{(2)}=\mat{c:c}{A'&B'\\\hdashline I& D'}_{2n\times2n}$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Canonical Form (contd.)
    $$H\to \boxed{CX}\to S\to CX\to S\to CX\to H\to S\to CX\to S\to CX$$
    - $(2.~CX)$ Ignoring phase, we apply $CX$ gates to perform gaussian elimination on $C$ submatrix.
      - We avoid row swapping/addition during Gaussian elim, since that may change the table to a non-equivalent circuit.
        - Even though final state doesn't change.

        $$T^{(2)}=\mat{c:c}{A'&B'\\\hdashline I& D'}_{2n\times2n}$$
      - We will likely need quite a lot of $CX$ gates here (unlike the single qubit gates).
      - But all of them acts as a linear operation on the tableau.
      - Each $CX$ works like a matrix multiplication on the tableau from the right. e.g. applying $CX$ and then $CX':$
        - $L_{CX}$ and $L_{CX'}$ is the corresponding linear operators on the tableau $T^{(1)}$.
        - Here, $J^2=K^2=I$. Also, we define $M=KJ$. Then, $M^{-1}=J^{-1}K^{-1}$ and $M^\top=J^\top K^\top$

            $$T^{(1)}L_{CX}L_{CX'}
            = T^{(1)}\mat{c:c}{J^{-1}&0\\\hdashline0&J^\top}\mat{c:c}{K^{-1}&0\\\hdashline0&K^\top}
            % = T^{(1)}\mat{c:c}{J&0\\\hdashline0&J^\top}\mat{c:c}{K&0\\\hdashline0&K^\top}
            % = T^{(1)}\mat{c:c}{JK&0\\\hdashline0&J^\top K^\top}
            = T^{(1)}\mat{c:c}{J^{-1}K^{-1}&0\\\hdashline0&J^\top K^\top}
            = T^{(1)}\mat{c:c}{M^{-1}&0\\\hdashline0&M^\top}$$
        - Crucially though, $M^2$ is not necessarily identity.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Canonical Form (contd.)
    $$H\to CX\to \boxed{S\to CX}\to S\to CX\to H\to S\to CX\to S\to CX$$
    - $(3.~S)$ Since stabilizer elements commute, $ID'^\top+D'I^\top=0\implies D'$ is symmetric.
      - We use $S$ gate on selective qubits to add necessary diagonal entries of $I$ to $D'$.
      - The, by the lemma on symmetric matrices, we can make it into $MM^\top=D'+\Lambda_S$.

        $$T^{(3)}=\mat{c:c}{A'&B''\\\hdashline I& MM^\top}_{2n\times2n}$$
    - $(4.~CX)$ We $CX$ so that the bottom submatrices are both $M$.
      - This is acheived by applying multiple $CX$ gates such that $J^{-1}=M\implies J=M^{-1}$.

        $$T^{(4)}=T^{(3)}L_{CX}
        = \mat{c:c}{A'&B''\\\hdashline I& MM^\top}\mat{c:c}{J^{-1}&0\\\hdashline0&J^\top}
        = \mat{c:c}{A'&B''\\\hdashline I& MM^\top}\mat{c:c}{M&0\\\hdashline0&(M^{-1})^\top}
        = \mat{c:c}{A'M&B''(M^{-1})^\top\\\hdashline M&MM^\top(M^{-1})^\top}$$
      - Simplifying $MM^\top(M^{-1})^\top=M$ and renaming submatrices we get,

        $$T^{(4)}=\mat{c:c}{A''&B'''\\\hdashline M&M}$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Canonical Form (contd.)
    $$H\to CX\to S\to CX\to \boxed{S}\to CX\to H\to S\to CX\to S\to CX$$
    - $(5.~S)$ Apply $S$ on all qubits to make a submatrix $0$ and fix phase information.
      - Apply $S$ on all $n$ qubits to make $Z$ submatrix of stablizier $0$.

        $$T^{(5)}=\mat{c:c}{A''&B''''\\\hdashline M&0}
        \xrightarrow[\textrm{ to erase stab phase}]{Z=S^2}
        \mat{c:c:c}{A''&B''''&\varphi\\\hdashline M&0&0}_{2n\times(2n+1)}$$
      - We also strategically apply some additional $S^2=Z$ to **erase all stabilizer phase information**.
        - This is done to match initial tableau which has no initial phase on stabs and destabs.
        - $Z=S^2$ keeps the $2n\times2n$ matrix same, but only affects phase as $r\longmapsto r\oplus x$.
        - Since $M$ is invertible, it is also full rank. Any $n\times1$ matrix can be written as sum of $M$'s columns (selective).
        - So, We can find columns where if $Z=S^2$ is applied, the stabilizer phase column can be nullified.

            $$M\mat{}{\smash{\overbrace{?}^{Z\textrm{~on qubit?}}}\\?\\\vdots\\?}_{\mathrlap{(2n\times1)}}
            \quad=\quad \mat{}{\smash{\overbrace{1}^{\textrm{phase info}}}\\0\\\vdots\\1}_{(2n\times1)}$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Canonical Form (contd.)
    $$H\to CX\to S\to CX\to S\to \boxed{CX}\to H\to S\to CX\to S\to CX$$
    - $(6.~CX)$ Apply $CX$ to convert $M$ to $I$.
      - We use $CX$ gates in such a way that performs Gaussian elimination on $M$.
      - Since the bottom-right submatrix is already $0$, it will still remain $0$ after $CX$.
      - Note that stabilzier phase information is also untouched since $z_b=0\implies r\longmapsto r\oplus0$.

        $$T^{(6)}=\mat{c:c}{A'''&B'''''\\\hdashline I&0}$$
      - Since stablizers and destabilizers mostly commute except at matching indices,

        $$A0^\top+I(B''''')^\top=\underbrace{I}_{\mathclap{\textrm{anti-commute at matching indices}}}
        \implies B'''''=I$$
      - Replacing this value in $T^{(6)}$, we get,

        $$T^{(6)}=\mat{c:c}{A'''&I\\\hdashline I&0}$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Canonical Form (contd.)
    $$H\to CX\to S\to CX\to S\to CX\to \boxed{H\to S}\to CX\to S\to CX$$

    - $(7.~H)$ Switch $X$ and $Z$ columns.
      - Apply $H$ on all $n$ qubits so that the columns switch.
        - That way bottom submatrices match initial tableau
      - Note that stabilzier phase information is also untouched since $z=0\implies r\longmapsto r\oplus0$.

        $$T^{(7)}=\mat{c:c}{I&A'''\\\hdashline 0&I}$$

    - $(8.~S)$ Add diagonal entries to make $A'''$ into $NN^\top$.
      - By the lemma of symmetric matrices, we have $A'''+\Lambda_S=NN^\top$.
      - Since the bottom-left submatrix is $0$ it doesn't affect bottom-right submatrix or phase info.

        $$T^{(8)}=\mat{c:c}{I&NN^\top\\\hdashline 0&I}$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Canonical Form (contd.)
    $$H\to CX\to S\to CX\to S\to CX\to H\to S\to \boxed{CX\to S}\to CX$$

    - $(9.~CX)$ Just like step 4.
      - Apply $CX$ gates to split $NN^\top$ into two $N$'s.
      - But this change bottom-right submatrix.
      - But phase info is unchanged since bottom-left submatrix is $0$. So, $r\longmapsto r\oplus0$

        $$T^{(9)}=\mat{c:c}{N&N\\\hdashline 0&C}$$

    - $(10.~S)$ Just like step 5.
      -  Apply $S$ gates to nullify $N$ on top-right submatrix.

        $$T^{(10)}=\mat{c:c}{N&0\\\hdashline 0&C}$$

      - Also apply necessary $Z=S^2$ gates to erase destabilizer phase information.
      - Anti/commutativity between de/stablizers imply that, $NC^\top+0=I\implies C^\top=N^{-1}$

      - Let $K=N^{-1}$. Then, $C^\top=K\implies C=K^\top$
      - Replacing the new names,

        $$T^{(10)}=\mat{c:c}{K^{-1}&0\\\hdashline 0&K^\top}$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Canonical Form (contd.)
    $$H\to CX\to S\to CX\to S\to CX\to H\to S\to CX\to S\to \boxed{CX}$$

    - $(11.~CX)$ Make it identity.
      - Apply $CX$ gates to such that the final tableau becomes initial tableau.

        $$T^{(11)}=T^{(10)}L_{CX}
        = \mat{c:c}{K^{-1}&0\\\hdashline 0& K^\top}\mat{c:c}{J^{-1}&0\\\hdashline0&J^\top}
        = \mat{c:c}{(JK)^{-1}&0\\\hdashline 0& (JK)^\top}$$
      - If we take $J=K^{-1}$, then, $JK=I$. That means,

        $$T^{(11)}=\mat{c:c}{I&0\\\hdashline 0&I}$$

      - Note that phase information erased in the previous steps remain untouched since either $z$ or $x$ is $0$.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    # Circuit Complexity
    - What's the gate complexity of this canonical form circuit? $\boxed{O(n^2/\log n)}$
    - For the Hadamard layers, we at most need one $H$ per qubit since $H^2=I$.
    - For the Phase gate layers, we at most need three $S$ per qubit since $S^4=I$.
    - So, we need $O(n)$ single qubit gates.
    - That means, the circuit complexity is dominated by the number of $CX$ gates.
    - Since each $CX$ layer only consists of $CX$'s, on the tableau the transformation will be right multiplication by:

    $$\mat{c:c}{L^{-1}&0\\\hdashline0&L^\top}$$
    - Each of the $C_aX_b$ acts as follows (where $J_{ab}=I+\ket a\!\!\bra b$ and so, $J_{ab}^2=I$):

    $$\mat{c:c}{J_{ab}^{-1}&0\\\hdashline0&J_{ab}^\top}\textrm{\qquad\qquad e.g.~~}
    J_{24} =
    % \mat{}{1&
    % \smash{\overbrace{0}^{\smash{\bullet\mathrlap{\rule[1pt]{1cm}{1pt}}}}}
    % &0&
    % \smash{\overbrace{0}^{\smash{\bigoplus\mathllap{\rule[1pt]{1cm}{1pt}}}}}\\
    % 0&1&0&\textcolor{red}{1}
    % \mathrlap{\scriptstyle~\bullet}\\
    % 0&0&1&0\mathrlap{~\smash{\rule[-0.5cm]{1pt}{1cm}}}\\
    % 0&0&0&1\mathrlap{\scriptstyle\bigoplus}}
    \mat{}{1&\smash{\overbrace0^{\smash{\bullet}\atop}}&0&\smash{\overbrace0^{\smash{\bigoplus}\atop}}\\
    0&1&0&\color{red}1\\
    0&0&1&0\\
    0&0&0&1}
    \begin{array}{lc}
    \\
    \}&\scriptsize\bullet\\
    \\
    \}&\scriptsize\bigoplus
    \end{array}
    $$

    - Each of these $J_{ab}$ matrices for each $CX$ gate can be seen as elementary row/column operation.
    - So, we can view the $CX$'s as performing gaussian elimination on the matrix $L$.
    - Since $L$ is a $(n\times n)$ matrix, we need $O(n^2)$ such operations to reach RREF.
    - Hence, the $CX$ layers can be acheived by $O(n^2)$ gates.
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Circuit Complexity (contd.)
    - Shannon's counting argument says the lower bound is $\Omega(n^2/\log n)$ gates.
    - **Proof:**
      - Since any such $L$ representing any $n$-qubit $CX$ circuit must be invertible ($L^{-1}$ exists),
        - And we can make any row addition operation using a single $CX$ gate,
        - We can always use RREF to reach $I$. (Hence, the argument in last slide)
        - But this implies that we can make any rank $n$ matrix (so, invertible) by applying $CX$'s on $I$.
          - Because we can always reverse the row ops (or, the $CX$'s) on $I$ to build the matrix $L$.
        - So, set of all $CX$ cicuits is not only a subset of $n\times n$ invertible binary matrix $\textrm{GL}_n(\Z_2)$, but actually equal to it.
      - So, $|\Set{U_{CX's}}|=|\textrm{GL}_n(\Z_2)|$. Let's count the number of invertible $n\times n$ binary matrices.
        - Since $L$ have rank $n$, any non-trivial sum of rows must be non-zero.
        - For the 1st row, we have $2^n-1$ choices. $-1$ for excluding an all-zero row.
        - For the 2nd row, we have $2^n-2$ choices. (excluded $0$ and $r_1$)
        - For the 3rd row, we have $2^n-4$ choices. (excluded $0, r_1, r_2$ and $r_1+r_2$)
        - Contuning like this, for the $n$-th row, we have $2^n-2^{n-1}$ choices.
        - So, $\displaystyle|\textrm{GL}_n(\Z_2)| = \prod_{k=1}^{n}(2^n-2^{n-k})$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""
    ## Circuit Complexity (contd.)
    - **Proof:** (contd.)
      - How many $CX$ gates do we need to make all possible $CX$ circuits?
        - Let $d$ be the maximum number of $CX$ gates needed for this.
        - In an $n$-qubit circuit, we can place a $CX$ gate in $n(n-1)$ possible ways.
        - with $\leq d$ gates we can make $[n(n-1)+1]^d$ circuits.
          - $+1$ to account for not placing any gates (for $<d$ gates)
        - If this needs to cover all possible $CX$ circuits, then,

            $$(n^2-n+1)^d\geq \prod_{k=1}^{n}(2^n-2^{n-k})$$
        - But since $(2^n-2^{n-k})\geq2^{n-1}$ for all $k=1\cdots n,$ then,

            $$\begin{align*}
            &(n^2-n+1)^d\geq\prod_k2^{n-1}=2^{n(n-1)}\\
            \implies& d\cdot\log_2(n^2-n+1)\geq n(n-1)\\
            \implies& d\geq\frac{n^2-n}{\log_2(n^2-n+1)}=O\left(\frac{n^2}{\log n}\right)\\
            \therefore~& d=\Omega\left(\frac{n^2}{\log n}\right)
            \end{align*}$$
    """)
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(rf"""
    ## Circuit Complexity (contd.)
    - But is there any scheme that reaches this lower bound of $\Omega(n^2/\log n)$?
      - Yes. Shown by Patel, Markov and Hayes [18].
    - Patel et al.'s $O(n^2/\log n)$ scheme:
    """)
    return


@app.cell
def _(mo):
    mo.pdf(src="public/Aaronson-Gottesman_stabilizer_simulation_0406196.pdf#view=FitH&page=23")
    return


if __name__ == "__main__":
    app.run()
